using Content.Shared.Body.Part;
using Content.Shared.Body.Systems;
using Content.Shared.Damage;
using Content.Shared.MedicalScanner;
using Robust.Client.AutoGenerated;
using Robust.Client.UserInterface.Controls;
using Robust.Client.UserInterface.XAML;
using System.Linq;

namespace Content.Client.HealthAnalyzer.UI;

[GenerateTypedNameReferences]
public sealed partial class HealthAnalyzerBodyWindow : BaseHealthAnalyzerWindow
{
    private readonly SharedBodySystem _bodySystem;

    private BodyPart? SelectedPart;
    public bool Updateable = true;

    public HealthAnalyzerBodyWindow()
    {
        RobustXamlLoader.Load(this);

        _bodySystem = _entityManager.System<SharedBodySystem>();
    }

    public override void Populate(HealthAnalyzerScannedUserMessage msg)
    {
        var target = _entityManager.GetEntity(msg.TargetEntity);

        if (target == null || _bodySystem.GetBodyDamage(target.Value) is not {} damage)
        {
            NoPatientDataText.Visible = true;
            return;
        }

        NoPatientDataText.Visible = false;

        DrawScanMode(ScanModeLabel, msg.ScanMode);
        DrawPatient(SpriteView, NoDataTex, NameLabel, SpeciesLabel, target.Value, msg.ScanMode);
        DrawBasicDiagnostics(TemperatureLabel, BloodLabel, StatusLabel, DamageLabel, target.Value, msg.Temperature, msg.BloodLevel, damage.GetTotal());

        var showAlerts = DrawAlerts(AlertsContainer, msg.Unrevivable, msg.Bleeding);
        AlertsDivider.Visible = showAlerts;
        AlertsContainer.Visible = showAlerts;

        var healthBodyComp = _entityManager.GetComponent<HealthAnalyzerBodyComponent>(target.Value);

        Dictionary<BodyPart, (EntityUid Uid, DamageableComponent Damageable, HealthAnalyzerLimb Data, TextureRect Texture)> limbs = new();

        foreach (var (limbUid, limbComp) in _bodySystem.GetBodyChildren(target.Value))
        {
            var part = new BodyPart(limbComp.PartType, limbComp.Symmetry);
            if (!healthBodyComp.Limbs.TryGetValue(part, out var data))
                continue;

            if (!_entityManager.TryGetComponent<DamageableComponent>(limbUid, out var damageable))
                continue;

            if (!_entityManager.TryGetComponent<BodyPartThresholdsComponent>(limbUid, out var thresholdsComp) || !thresholdsComp.Thresholds.TryGetValue(WoundState.Dead, out var deadThreshold))
                continue;

            var progressBar = GetProgressBar(part);
            progressBar.Visible = true;

            progressBar.ProgressLabel.Text = Loc.GetString($"health-analyzer-body-{part.Side.ToString().ToLower()}-{part.Type.ToString().ToLower()}");
            progressBar.ProgressTex.Progress = Math.Abs((float) (damageable.TotalDamage / deadThreshold) - 1);
            progressBar.ProgressText.Text = $"{deadThreshold - damageable.TotalDamage}/{deadThreshold}";

            var button = GetButton(part);
            button.Texture = _spriteSystem.Frame0(data.HoverSprite);
            button.Visible = true;

            limbs.Add(part, (limbUid, damageable, data, button));
        }

        Updateable = true;

        LimbButton.OnPressed += args =>
        {
            if (!Updateable)
                return;

            var selectableLimbs = new Dictionary<BodyPart, (EntityUid, DamageableComponent, HealthAnalyzerLimb, TextureRect)>(limbs);

            if (SelectedPart is {})
                selectableLimbs.Remove(SelectedPart);

            foreach (var (part, (_, _, data, button)) in selectableLimbs)
            {
                var selectedTexture = _spriteSystem.Frame0(data.SelectedSprite);
                var scale = selectedTexture.Size / LimbButton.Size;
                var pixel = scale * args.Event.RelativePosition;

                var color = selectedTexture.GetPixel(Math.Round(pixel.X), Math.Round(pixel.Y));

                if (color != Color.Transparent && color != new Color())
                {
                    SelectedPart = part;
                    break;
                }
            }

            Updateable = false;
        };

        if (SelectedPart is {} && limbs.TryGetValue(SelectedPart, out var limbData))
        {
            DrawLimbDamage(limbData.Damageable.Damage);
            limbData.Texture.Texture = _spriteSystem.Frame0(limbData.Data.SelectedSprite);
        }
        else
        {
            foreach (var (part, (limb, _, data, button)) in limbs)
                button.Texture = _spriteSystem.Frame0(data.SelectedSprite);

            DrawLimbDamage(damage);
        }
    }

    private void DrawLimbDamage(DamageSpecifier damage)
    {
        var damageSortedGroups =
            damage.GetDamagePerGroup(_prototypes).OrderByDescending(damage => damage.Value)
                .ToDictionary(x => x.Key, x => x.Value);

        GroupsContainer.RemoveAllChildren();
        foreach (var container in DrawDiagnosticGroups(damageSortedGroups, damage.DamageDict))
            GroupsContainer.AddChild(container);
    }

    private HealthAnalyzerBodyProgressBar GetProgressBar(BodyPart bodyPart)
    {
        return bodyPart.Type switch
        {
            BodyPartType.Head => bodyPart.Side switch
            {
                BodyPartSymmetry.None => ProgressBarHead,
                _ => throw new NotImplementedException(),
            },
            BodyPartType.Torso => bodyPart.Side switch
            {
                BodyPartSymmetry.None => ProgressBarTorso,
                _ => throw new NotImplementedException(),
            },
            BodyPartType.Arm => bodyPart.Side switch
            {
                BodyPartSymmetry.Left => ProgressBarLeftArm,
                BodyPartSymmetry.Right => ProgressBarRightArm,
                _ => throw new NotImplementedException(),
            },
            BodyPartType.Leg => bodyPart.Side switch
            {
                BodyPartSymmetry.Left => ProgressBarLeftLeg,
                BodyPartSymmetry.Right => ProgressBarRightLeg,
                _ => throw new NotImplementedException(),
            },
            _ => throw new NotImplementedException(),
        };
    }

    private TextureRect GetButton(BodyPart bodyPart)
    {
        return bodyPart.Type switch
        {
            BodyPartType.Head => bodyPart.Side switch
            {
                BodyPartSymmetry.None => ButtonHead,
                _ => throw new NotImplementedException(),
            },
            BodyPartType.Torso => bodyPart.Side switch
            {
                BodyPartSymmetry.None => ButtonTorso,
                _ => throw new NotImplementedException(),
            },
            BodyPartType.Arm => bodyPart.Side switch
            {
                BodyPartSymmetry.Left => ButtonLeftArm,
                BodyPartSymmetry.Right => ButtonRightArm,
                _ => throw new NotImplementedException(),
            },
            BodyPartType.Leg => bodyPart.Side switch
            {
                BodyPartSymmetry.Left => ButtonLeftLeg,
                BodyPartSymmetry.Right => ButtonRightLeg,
                _ => throw new NotImplementedException(),
            },
            _ => throw new NotImplementedException(),
        };
    }
}
