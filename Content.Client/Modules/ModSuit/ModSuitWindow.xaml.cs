using Content.Client.Modules.ModSuit.Modules;
using Content.Shared.Modules.ModSuit.UI;
using Content.Shared.Modules.ModSuit.UI.Modules;
using Robust.Client.AutoGenerated;
using Robust.Client.UserInterface.CustomControls;
using Robust.Client.UserInterface.XAML;
using System.Linq;

namespace Content.Client.Modules.ModSuit;

[GenerateTypedNameReferences]
public sealed partial class ModSuitWindow : DefaultWindow
{
    private KeyValuePair<NetEntity, ModSuitSealableBuiEntry>[] _sealableParts = [];
    private KeyValuePair<NetEntity, ModSuitBaseModuleBuiEntry>[] _modules = [];
    private (int, int)? _complexity = null;

    public event Action<Dictionary<NetEntity, bool>>? OnSealButtonPressed;

    // Module buttons
    public event Action<NetEntity, bool>? OnToggleButtonPressed;
    public event Action<NetEntity>? OnEjectButtonPressed;
    public event Action<NetEntity, Color>? OnFlashlightColorChanged;

    public ModSuitWindow()
    {
        RobustXamlLoader.Load(this);
        IoCManager.InjectDependencies(this);
    }

    public void Refresh()
    {
        RefreshSealableIcons();
        RefreshModules();
    }

    #region Sealable

    public void UpdateSealed(ModSuitSealableBoundUserInterfaceState state)
    {
        if (_sealableParts == state.Parts)
            return;

        _sealableParts = state.Parts;
        RefreshSealableIcons();
    }

    internal void RefreshSealableIcons()
    {
        SealContainer.Visible = _sealableParts.Any();
        SealPanel.RemoveAllChildren();
        SealButtons.RemoveAllChildren();

        var anyUnsealed = false;

        foreach (var (part, data) in _sealableParts)
        {
            var spriteView = new ModSuitSealableSprite(data.Sprite[data.IsSealed]);
            SealPanel.AddChild(spriteView);

            var button = new ModSuitSealableButton(part, data.IsSealed);
            SealButtons.AddChild(button);

            Dictionary<NetEntity, bool> sealedButtonState = [];
            sealedButtonState.Add(part, !data.IsSealed);
            button.ButtonButton.OnPressed += _ => OnSealButtonPressed?.Invoke(sealedButtonState);

            if (!data.IsSealed)
                anyUnsealed = true;
        }

        if (_sealableParts.Any())
        {
            var allButton = new ModSuitSealableAllButton(!anyUnsealed);
            SealButtons.AddChild(allButton);

            Dictionary<NetEntity, bool> sealedButtonState = [];
            foreach (var (part, data) in _sealableParts)
            {
                if (data.IsSealed == anyUnsealed)
                    continue;

                sealedButtonState.Add(part, !data.IsSealed);
            }

            allButton.ButtonButton.OnPressed += _ => OnSealButtonPressed?.Invoke(sealedButtonState);
        }
    }

    #endregion

    #region Complexity

    public void UpdateComplexity(ModSuitComplexityBoundUserInterfaceState state)
    {
        _complexity = state.Complexity;
        RefreshComplexity();
    }

    internal void RefreshComplexity()
    {
        if (_complexity == null)
        {
            ComplexityContainer.Visible = false;
            return;
        }

        var (complexity, max) = _complexity.Value;

        ComplexityContainer.Visible = true;
        ComplexityLabel.Text = Loc.GetString("modsuit-interface-complexity", ("complexity", complexity), ("max", max));
    }

    #endregion

    #region Modules

    public void UpdateModules(ModSuitModuleBoundUserInterfaceState state)
    {
        if (_modules == state.Modules)
            return;

        _modules = state.Modules;
        RefreshModules();
    }

    internal void RefreshModules()
    {
        ModuleList.RemoveAllChildren();

        foreach (var (module, data) in _modules)
        {
            // order matters
            // more likely to be parented goes at the bottom
            switch (data)
            {
                case ModSuitFlashlightModuleBuiEntry flashlightEntry:
                    var flashlightPanel = new ModSuitFlashlightModulePanel(module, flashlightEntry);
                    ModuleList.AddChild(flashlightPanel);
                    flashlightPanel.ToggleButton.OnPressed += _ => OnToggleButtonPressed?.Invoke(module, flashlightPanel.ToggleButton.Pressed);
                    flashlightPanel.EjectButton.OnPressed += _ => OnEjectButtonPressed?.Invoke(module);
                    flashlightPanel.ColorSelector.OnColorChanged += (color) => OnFlashlightColorChanged?.Invoke(module, color);
                    break;

                case ModSuitBaseToggleableModuleBuiEntry toggleableEntry:
                    var toggleablePanel = new ModSuitBaseToggleableModulePanel(module, toggleableEntry);
                    ModuleList.AddChild(toggleablePanel);
                    toggleablePanel.ToggleButton.OnPressed += _ => OnToggleButtonPressed?.Invoke(module, toggleablePanel.ToggleButton.Pressed);
                    toggleablePanel.EjectButton.OnPressed += _ => OnEjectButtonPressed?.Invoke(module);
                    break;

                case ModSuitBaseModuleBuiEntry baseEntry:
                    var basePanel = new ModSuitBaseModulePanel(module, baseEntry);
                    ModuleList.AddChild(basePanel);
                    basePanel.EjectButton.OnPressed += _ => OnEjectButtonPressed?.Invoke(module);
                    break;

                default:
                    throw new NotImplementedException($"Tried to convert {data.GetType()} to a panel which does not exist.");
            }
        }
    }

    #endregion
}
