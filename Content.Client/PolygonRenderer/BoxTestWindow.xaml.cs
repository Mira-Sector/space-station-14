using Content.Client.UserInterface.Controls;
using Content.Shared.PolygonRenderer;
using Robust.Client.AutoGenerated;
using Robust.Client.Graphics;
using Robust.Client.UserInterface.XAML;
using Robust.Shared.Prototypes;
using Robust.Shared.Timing;
using Vector3 = Robust.Shared.Maths.Vector3;

namespace Content.Client.PolygonRenderer;

[GenerateTypedNameReferences]
public sealed partial class BoxTestWindow : FancyWindow
{
    [Dependency] private readonly IPrototypeManager _prototype = default!;
    [Dependency] private readonly IGameTiming _timing = default!;

    private static readonly ProtoId<PolygonModelPrototype> BoxId = "TestBox";
    private readonly PolygonModel _box;

    private const uint BoxCount = 3;
    private const float SpacePerBox = 0.25f;

    private const float UpdateRate = 1f / 30f;
    private float _accumulator;

    private Angle _rotation = Angle.Zero;
    private static readonly Angle RotationRate = new(0.01 / UpdateRate);

    private static readonly Vector3 CameraPos = new(-1, -1, -2);
    private static readonly Matrix4 Camera = Matrix4.CreateTranslation(CameraPos);

    public BoxTestWindow()
    {
        RobustXamlLoader.Load(this);
        IoCManager.InjectDependencies(this);

        _box = _prototype.Index(BoxId);
        Renderer.Camera = Camera;
        Renderer.Models = new PolygonModel[BoxCount];
        for (var i = 0; i < BoxCount; i++)
            Renderer.Models[i] = NewBox(i);
    }

    protected override void Draw(DrawingHandleScreen handle)
    {
        base.Draw(handle);

        _accumulator -= (float)_timing.FrameTime.TotalSeconds;
        if (_accumulator > 0f)
            return;

        _accumulator = MathF.Max(0f, _accumulator + UpdateRate);
        _rotation += RotationRate;
        _rotation.Reduced();

        for (var i = 0; i < BoxCount; i++)
            Renderer.Models[i].ModelMatrix = GetBoxMatrix(i);
    }

    private PolygonModel NewBox(int index)
    {
        return new PolygonModel(_box.Polygons, GetBoxMatrix(index));
    }

    private Matrix4 GetBoxMatrix(int index)
    {
        var offset = index;
        if ((index & 1) == 1)
            offset += 1;

        var position = new Vector3(SpacePerBox * offset, 0f, 0f);

        if ((index & 1) == 1)
            position *= -1;

        return Matrix4.CreateRotationX((float)_rotation) * Matrix4.CreateTranslation(position);
    }
}
