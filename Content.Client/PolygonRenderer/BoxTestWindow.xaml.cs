using Content.Client.UserInterface.Controls;
using Content.Shared.PolygonRenderer;
using Robust.Client.AutoGenerated;
using Robust.Client.Graphics;
using Robust.Client.UserInterface.XAML;
using Robust.Shared.Prototypes;
using Robust.Shared.Timing;

namespace Content.Client.PolygonRenderer;

[GenerateTypedNameReferences]
public sealed partial class BoxTestWindow : FancyWindow
{
    [Dependency] private readonly IPrototypeManager _prototype = default!;
    [Dependency] private readonly IGameTiming _timing = default!;

    internal static readonly ProtoId<PolygonModelPrototype> BoxId = "TestBox";
    internal PolygonModel Box;

    internal const uint BoxCount = 3;
    internal const float SpacePerBox = 0.25f;

    internal const float UpdateRate = 1f / 30f;
    internal float Accumulator;

    internal float Rotation = 0f;

    internal static readonly Vector3 Camera = new()
    {
        X = -1,
        Y = -1,
        Z = -2
    };

    public BoxTestWindow()
    {
        RobustXamlLoader.Load(this);
        IoCManager.InjectDependencies(this);

        Box = _prototype.Index(BoxId);
    }

    protected override void Draw(DrawingHandleScreen handle)
    {
        base.Draw(handle);

        Accumulator -= (float)_timing.FrameTime.TotalSeconds;
        if (Accumulator > 0f)
            return;

        Accumulator = MathF.Max(0f, Accumulator + UpdateRate);
        Rotation += UpdateRate;

        var modelArray = new PolygonModel[BoxCount];
        for (var i = 0; i < BoxCount; i++)
            modelArray[i] = NewBox(i);

        Renderer.Models = modelArray;
        Renderer.Camera = Camera;
    }

    internal PolygonModel NewBox(int index)
    {
        var newBox = new PolygonModel();
        newBox.Polygons = Box.Polygons;

        var offset = index;
        if ((index & 1) == 1)
            offset += 1;

        var rotation = new Vector3(Rotation * offset, index, Rotation * offset * 0.5f);
        var position = new Vector3(SpacePerBox * offset, 0f, 0f);

        if ((index & 1) == 1)
            position *= -1;

        newBox.Rotation = rotation;
        newBox.Position = position;

        return newBox;
    }
}
