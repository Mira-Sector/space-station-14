using Content.Client.UserInterface.Controls;
using Content.Shared.Teleportation.Components;
using Content.Shared.Telescience;
using Content.Shared.Telescience.Components;
using Content.Shared.Telescience.Ui;
using Robust.Client.AutoGenerated;
using Robust.Client.UserInterface.XAML;
using Robust.Shared.Map;
using Robust.Shared.Timing;

namespace Content.Client.Telescience.Ui;

[GenerateTypedNameReferences]
public sealed partial class TeleframeConsoleWindow : FancyWindow
{
    [Dependency] private readonly IEntityManager _entMan = default!;
    [Dependency] private readonly IGameTiming _timing = default!;
    private readonly SharedTransformSystem _transform;

    private Entity<TeleframeConsoleComponent, TransformComponent>? _console;
    private MapCoordinates? _coords;
    private TeleportPoint? _currentBeacon;
    private Vector2i? _currentCoords;

    public event Action<TeleframeActivateMessage>? OnActivated;

    public TeleframeConsoleWindow()
    {
        RobustXamlLoader.Load(this);
        IoCManager.InjectDependencies(this);

        _transform = _entMan.System<SharedTransformSystem>();

        CoordsX.OnValueChanged += e => OnCoordsChanged(new((int)e.Value, (int)CoordsY.Value));
        CoordsY.OnValueChanged += e => OnCoordsChanged(new((int)CoordsX.Value, (int)e.Value));

        SendToButton.OnPressed += _ => SendActivateMessage(TeleframeActivationMode.Send);
        ReceiveFromButton.OnPressed += _ => SendActivateMessage(TeleframeActivationMode.Receive);
        RefreshButton.OnPressed += _ => OnRefreshClicked();
    }

    public void UpdateState(Entity<TeleframeConsoleComponent, TransformComponent> ent)
    {
        _console = ent;

        _coords = _transform.GetMapCoordinates(ent.Owner, ent.Comp2);

        var beacons = GetValidBeacons(ent.Comp1.BeaconList);
        AddBeaconButtons(beacons);

        TeleportCheck(ent, false, Loc.GetString("teleporter-summary-insufficient"));
    }

    private void OnCoordsChanged(Vector2i coords)
    {
        var ent = _console!.Value;

        bool coordsValid;

        _currentBeacon = null; //if typing in text, invalidate beacon teleport
        var message = Loc.GetString("teleporter-summary-insufficient");
        if (ent.Comp1.MaxRange == null || coords.LengthSquared < ent.Comp1.MaxRange * ent.Comp1.MaxRange) //range from console rather than teleporter because it's simpler to code.
        {
            coordsValid = true;
        }
        else
        {
            message = Loc.GetString("teleporter-summary-bigrange", ("range", ent.Comp1.MaxRange));
            coordsValid = false;
        }

        if (coordsValid)
        {
            message = Loc.GetString("teleporter-summary-custom", ("X", coords.X), ("Y", coords.Y));
            _currentCoords = coords;
        }
        else
        {
            _currentCoords = null;
        }

        TeleportCheck(ent, coordsValid, message);
    }

    private void OnBeaconClicked(TeleportPoint beacon)
    {
        _currentCoords = null;
        _currentBeacon = beacon;
        TeleportCheck(_console!.Value, true, Loc.GetString("teleporter-summary-beacon", ("beacon", beacon.Location)));
    }

    private void OnRefreshClicked()
    {
        TeleportCheck(_console!.Value, !SendToButton.Disabled, SummaryLabel.Text!);
    }

    private void SendActivateMessage(TeleframeActivationMode mode)
    {
        TeleframeActivateMessage msg;

        //for beacons have an if that is true if beacon selected and false if not. If true, use a separate activate message.
        if (_currentCoords is { } coords)
            msg = new TeleframeActivateMessage(new MapCoordinates(coords.X, coords.Y, _coords!.Value.MapId), Loc.GetString("teleporter-target-custom"), mode);
        else if (_currentBeacon is { } beacon)
            msg = new TeleframeActivateMessage(_transform.GetMapCoordinates(_entMan.GetEntity(beacon.TelePoint)), beacon.Location, mode, true);
        else
            return;

        OnActivated?.Invoke(msg);
        TeleportCheck(_console!.Value, false, Loc.GetString("teleporter-summary-notready"));
    }

    //get valid beacons only, also make sure beacons exist!
    private IEnumerable<TeleportPoint> GetValidBeacons(IEnumerable<TeleportPoint> totalList)
    {
        foreach (var beacon in totalList)
        {
            if (!_entMan.TryGetEntity(beacon.TelePoint, out var beaconEnt))
                continue;

            if (!_entMan.TryGetComponent<TeleframeBeaconComponent>(beaconEnt, out var beaconComp))
                continue;

            if (beaconComp.ValidBeacon)
                yield return beacon;
        }
    }

    private string GetChargeState(EntityUid uid, TeleframeComponent tpComp)
    {
        if (tpComp.IsPowered == false)
            return Loc.GetString("teleporter-unpowered");

        if (_entMan.TryGetComponent<TeleframeChargingComponent>(uid, out var charge))
        {
            var timeLeft = (int)(charge.EndTime - _timing.CurTime).TotalSeconds;
            return Loc.GetString("teleporter-charging", ("time", timeLeft));
        }

        if (_entMan.TryGetComponent<TeleframeRechargingComponent>(uid, out var recharge))
        {
            if (recharge.Pause == false)
            {
                var timeLeft = (int)(recharge.EndTime - _timing.CurTime).TotalSeconds;
                return Loc.GetString("teleporter-recharging", ("time", timeLeft));
            }
            else
            {
                return Loc.GetString("teleporter-recharging", ("time", "paused"));
            }
        }

        return Loc.GetString("teleporter-active");
    }

    //check if teleportation console and linked teleframe are valid
    //return true if they are (doesn't mean teleportation is possible)
    //check should be performed any time teleportation possibility changes
    //check should be performed consistently outside this too, not sure how to do that, could just add a refresh button.
    private bool TeleportCheck(Entity<TeleframeConsoleComponent> ent, bool buttons, string message)
    {
        if (ent.Comp.LinkedTeleframe != null) //set link name
        {
            var (linked, meta) = _entMan.GetEntityData(ent.Comp.LinkedTeleframe.Value);
            if (!_entMan.TryGetComponent<TeleframeComponent>(linked, out var tpComp))
                return false;

            SetLinkName(Loc.GetString("teleporter-linked-to", ("name", meta.EntityName), ("state", GetChargeState(linked, tpComp)))); //kind of want a sprite here as well

            if (!tpComp.IsPowered || !tpComp.ReadyToTeleport)
            {
                UpdateTeleportButtons(false);
                UpdateTeleportSummary(Loc.GetString("teleporter-summary-notready"));
                return true;
            }
        }
        else
        {
            SetLinkName(Loc.GetString("teleporter-linked-to", ("name", Loc.GetString("teleporter-linked-default")), ("state", Loc.GetString("teleporter-linked-default"))));
            UpdateTeleportButtons(false);
            UpdateTeleportSummary(Loc.GetString("teleporter-summary-unavailable"));
            return true;
        }

        UpdateTeleportButtons(buttons);
        UpdateTeleportSummary(message);
        return true;
    }

    private void AddBeaconButtons(IEnumerable<TeleportPoint> beacons)
    {
        BeaconButtonContainer.RemoveAllChildren();

        foreach (var beacon in beacons)
        {
            var button = new TeleframeConsoleBeaconButton(beacon);
            button.OnPressed += _ => OnBeaconClicked(beacon);
            BeaconButtonContainer.AddChild(button);
        }
    }

    private void SetLinkName(string link)
    {
        LinkLabel.Text = link;
    }

    private void UpdateTeleportSummary(string summary)
    {
        SummaryLabel.Text = summary;
    }

    private void UpdateTeleportButtons(bool valid)
    {
        SendToButton.Disabled = !valid;
        ReceiveFromButton.Disabled = !valid;
    }

}
